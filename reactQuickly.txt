// used for displaying components

// in these five steps
// 1. import react lib dom 
// why two libraries?
// react understands and reads components and how multiple components work together. cant display components in the browswer
import React from 'react'

// react dom understands how to get components to show up in the browser
// converts jsx to html
import ReactDOM from 'react-dom/client'

// 2. hook onto html elelment with root id
const el = document.getElementById('root')

// 3. take control of the elelment
// tell reactDom to show are app in the browser 
const root = ReactDOM.createRoot(el)

// 4. create a component
// functions to return jsx
// eg.1
// let App = ()=>{
//     // display js vars in jsx
//     // create var: vars can be of any data type but know that react cant render bool. so all dataTypes i.e string Nums bigInt symbols etc, but not true, false, null and undefined 

//     // datastructures for vars in react. array elements gets smushed into one value, and objects are nit valid react children
//     let variable = 'hello world'
//     let name = 'david'
//     // use of conditionals
//     if(Math.random()>0.1){
//         // change var based on condition
//         variable = 'hello guys'
//     }
//     // use interpolation{} to return a js var or an expression
//     // {} can also be used like template literals. for running pure js expressions. cant mix values in {}
//     return(<h1>{variable}. My name is {name} and the time is {new Date().toLocaleString()}</h1>)
// }
/////////////////////////////////////////////////////////////////
// eg 2
// costumize element with props
// let App = ()=>{
//     // input
//     // props is short for properties. 
//     // we use props to costumize elements in jsx.
//     // we can use js to specify props to be referenced inside elements
//     // props can be of string and numbers, but of also arrays and objects
//     // arrays and objects are to be wrapped with curly {} jst like numbers
//     let arr = [1,2,3]
//     let obj = {color:'red'}
//     let mins = 5
//     return(
//         <input type='number' max={10} min={mins} style={obj} list={arr}></input>
//     )
//     // when specifiying props directly on elements. if string wrap with "number", if number wrap with {3} 
// }

////////////////////////////////////////////////////////////////////
//textArea auto focus doesnt work in jsx how it does in html
// convert html to jsx in 5 steps
// 1. all props follow camelCase, maxlength is now maxLength 
// 2. props meant for numbers should be wrapped in curly braces{4},maxLength={4}
// 3. probs meant for booleans should be wrapped in {}, in case of 'true' there is no need to specify true. ie spellCheck, but if false specify it in {}, spellCheck={false}
// 4. in jsx className is the same as class in html. classes are used in styling for css. jsx is written in javascript and class in js is a keyword
// 5. in jsx inlin css styles are in objects. properties are specified with camelCases. ie padding-top is paddingTop

let App = ()=>{
    let csss = {
        border:'6px solid red',
        paddingTop:'100px'
    }
return(<textarea maxLength={5} autoFocus={true} spellCheck={false} style={csss}></textarea>)
} 

// 5. show the component on screen
// display component with root(the element react has taken control over)
// element.render(<component />)
root.render(<App/>)

jsx is important. it makes structuring the app easier. Easier to read to

in using the old react.create element. Once the code base grows the code brcomes harder to read and to avoid bugs.

ie what do elements do. jsx doesnt auto appear in the browser. it just tells react what elements to create. for jsx to appear in the browser we need to use the return keyword

////////////////////////
three tenets of components-design

1. nesting- show a component inside a components

2. reusabilty- components that we can use over and over again without rewriting the component. ie) buttons do the same thing. Show some text and do something when clicked. components are basically little pieces of code for that can be reuse in many diff apps

3. Configuration- config components when they are created- even as components can be reused(buttons etc). we should still be able to add some costum features to them.


////////////////////////////////////////////////
steps to create reusable components
step.1 identify jsx that is duplicate. components follow the dry principle. we write code once but reuse it in multiple parts of the codebase rather than writing similar code every time we need to perform the same operation over and over again

step.2 once duplicate jsx is spotted we try to isolate the code and give it a very discriptive name in relation to its purpose. ie if we have a jsx comment component and we dupicate the jsx to produce multiple components. we should instead  get the comment jsx and and turn it into a stand alone comment component 
like so const CommentDetail = ()=>{return()}

step3. once jsx has been made into a stand alone component. the next thing to do is to send the component to its own standAlone module. the module file should be named after the component. ie. CommentDetail.js should hold the CommentDetail component

step4. Once file is created move the jsx component to the file. 

step.5 make the components configurable with props. if parts of jsx are hard coded when it should be dynamic. use props to make it costum. like do not hard code dates, user names etc they should be dynamic


////////////////////////////////////////////////
nesting components
steps to render nested component
step1. export component from component module
step2. import component module into app or index.js.
do not use interpolation to render, that is for js vars. Instead render 
component like so <Component />

/////////////////////////////////////////////////
understand component hierachy

////////////
props for properties
props sysytem- systems for passing Data from the parent component to the child components. this is what makes components dynamic and costumization. think of props as js vars that look like html attributes. this props make componenets more dynamic. childrren cant pass props to parents directly

visaulize app like an object
// one istance of app. the app holds the children. App is the parent
// the children are inside app. the need to be in app to be rendered.ie-CommentDetailz

let App = {
    ApprovalCard:{
        CommentDetail:,
    }
}

//////////////////////////
passing props
there are two stages for using react props system.
// 1. passing the props down
// 2. consuming props passed down

when passing down props or providing props. 
1. we specify props in the component tags. <Component NameOfProps='Mr.propsMans'/>

2.props names should make sense in relation to the Component features
ie authorOfComment='Name'

3. props are unique to the component instance it was specified in
<Component ThisIsMyProp='iDontLikeSharingMyPropsWithAnyone'/>
<Component ThisIsMyVeryOwnProp='iDontLikeSharingMyPropsWithAnyoneToo'/>
<Component ThisIsMyVeryOwnPropJstForMe='meToo'/>

when consuming props. with child

when consuming props.
1. the first arguement for the component(the funct that returns jsx) is meant for the props obj. we get access to it if specified as a param in the component

2. use interpolations to insert into jsx. its basically javascript values. again use {props.someShit}

3. they work like varaibles in js

4. props can be passed into jsx elelments || html attributes like src ,href, className etc

let  Comp = (props)=>{
    return(<div className={props.AclassName}>{props.someData}<div/>)
} 

///////////////////////////////
passing multiple props
we can also pass multiple props into components
<Component 1Prop='meIam1' 2Prop='meIam2' 3Prop='meIam3'>


//////////////////////////////////
components reusablity
@TODO: Approval card. to practice reusable component.
1. create reusable component. create standAlone component with its own module file

////passing components as props
1. we can pass props as attributes in jsx 
2. but to pass a component as a prop we insert it between the component tags
i.e <ReusableComponent> <PropComponent/> </ReusableComponent>
3. comsume comp props as usuall (props)=>{}
4. component props are inside a nested children object.
5. consume props with interpolation <div>{props.children}</div>

///////////////////////////////////////////
class based componenets
- what are class based comps
1. class based components still serve the same purpose which is to return jsx.
2. but it can do more. class comps gives us abilty to use react Lifecycle methods. more on this laterOn.
3. also give use access to react state sysytem. to update content. more on this laterOn

// diff between class and function comps.
// early react used functions to only return jsx. functs cant use state sysytem or Lifecycle. was strictly for showing content. 
// but now react function component has Some thing called the hooks sysytem. more on this laterOn. but know the hooks gives functions the abilty to run code at specified time and gives functs access to react state system


// seasons app scarfold

// App comp. this takes in user data. to pass down to child
// seasons comp. this consumes data and renders text and icons based on data it recieves


// get user location. 
// the navigator Api can be found in the window object.
// we use the api like. window.navigator.geolaction.getCurrentPosition(Resolve CB, Reject CB)
// resolve cb f(n) runs when its succesful and the Data is return.
// reject cb f(n) runs when its unsuccesful and an err is return

// what happens in the app (fucn)
// browser loads js file- browser reads the file andd creates the app components. and invokes the component functio calling on the geoloc api
// once app is created. the browser calls the goeloc api
// app returns jsx instantly.
// the process is very synchronous. so any asynchronous operation will work if the app is rerendered

// the geoloc sevice is promised based. it takes some time to run and get data. before then the rest of our code already executed.
// we need away consume promise based operations

// refactor func to class
// rules to make class comps
// use js classes, Extent the React.Component class(inherit some features)
// must define a render() method that returns some jsx:so if you want the browser to display the content, we need render to return jsx.
// construction(). this fucn is important create instance of a class.
it is the very first fucn called when we create instances of a class. this makes it a good place to initialize state. 


// ///////////////////
state system in react
//1. helps with async operations in react
//2. updates and rerenders the app


// rules of the state system
// 1. only usable in class components
// 2. props can be confused with state
// 3. State is a js object that holds data relavant to a specific componnent. the data Obj is strictly revelant the component we are working one. ie. the will a specific state Obj for our App component
// 4. updating data in state. will instantly(almost) make our comp rerender.
if we want a our comp to rerender we must update state
// 5. state must be initialized once component is created
// 6. state can only be updated with setState() functions

// initializing state in class comp
// with the constructor(). this func is important because at any point the comp is instanciated the function will always be called. because it is called first its a good place to initialize the state.

// jst like the func comps the class comp also makes use of the props system. to pass data
// call super() funct. this func gives us access to the parent class functions and methods. because our class extends React.component class. we call super() for our class App has access to React.Component class funcs and meths
// call super(props)

// after adding the constructor func and calling the super(props) func, initialize state with an obj. the this KeyWord is a reference to our class(which is basically an object). so this.state = {}, also means ourClass.state={}. this enables us to refer to different methods and properties. in our class.

//e.g  constructor(props){
    super(props)
    this.state={}
  }

  ////////////////////////////////
  update state with props
  // because the state is initialized, we can access the state and its properties using this(remember this is a pointer to our class)
  // this.state.property

  // in the render funct we try not to perform long operations. this is because the render funct will get called many times. so to avoid running the same task over and over again. take long operations out of the render funct

  // update state and rerender
  // use setState() to update state. we pass in an obj as a param which will represent our state. setState({}), in the object we then set the property we needed to update.
  // i.e setState({property:'value'}). i know you are thinking if this.state.proptery = value would work. it wont, infact thats a bad idea.
  the only time we do a direct assignment is when initializing the state obj in the constructor, this.state={}. so in other words use setState({})



  ///////////
  // app life cycle summary.
  // js file is loaded in browser.
    - the browser read and runs our js file.
  // instance of App is created
    - the instance of our class app is created. because we use the constructor we have to use super to avod errors

  // state object is created and initialized. the state must be 'state' to work.basically assign an obj to state

  // we call the geoloc service. its a promise
  // react render the comp

  // then the geoloc promise is returned

  // the setState rerenders the app with new data


  /////////
  // error handling.
  // handle errors gracefully
  // create an error property in state. and update the property if error occurs.
  // this.state = {error:''}
  // if error ecountered. use setState({error:'error value'})
  // nb, when using () with the return statement. return() avoid using semicolon. ;. this ends a js statement. and cant return a block of jsx


///////////////
// conditional rendering
// you  can use if blocks to render conditionally.
// if(this.state.error){
    return(<div>error: {this.state.error}</div>)
}
// if(!this.state.property){
    return(<div>cant find data</div>)
}
return(data)


////////////////////////////
// Lifecycle methods
// these are optional methods given to us by react.
// if we use them. the methods would be called at certain times in a componenets life cycle.

class App {
    //1
    constructor(props){
        //1b
        super(props)
        //1c
        this.state={}
    }
    //2
    render(){show content}

    // life cycle methods give us the ability to perform certain operations at various stages in a components life cycle.
    componentDidMount(){
        // this is called as soon our app gets mounted in the browser. as the jsEngine reads our files and creates our app. this function is called.
    }
    // after being mounted our app sits around and waits for updates to the state obj
    componentDidUpdate(){
        // this func is called anytime our component is updated.
        any time setState({}) is called this func gets called
        // and anytime componentDidUpdate is called. the render methods is also called. and the jsx is return with the updated values
    }
    componentDidUnmount(){
        // this method would be called when our app is unmounted and no longer loaded in the browser
    }
}

// use like so
componentDidMount(){
    
  }
  componentDidUpdate(){
    
  }


////////////////////////////
// why LCM(life cycle methods) 
// didMount: used for initial app setup, dataloading, outside api calls,etc
// didUpdate: used for loading data that has been updated.change in state or props.
// willUnmount. used when removing comps and cleaning up code

////////////////////////////////////////////////////
// refactoring data loading to lifeCM
// use the componentDidMount fucn to help run set up code.
// ie when using the geoloc service. we need the service to be called as soon our app has been mounted. 
ie
// componentDidMount(){
window.navigator.geolocation.getCurrentPosition((position)=>{
    let latitude = position.coords.latitude
    let longitude = position.coords.longitude
    this.setState({lat:latitude,lng:longitude})
},(err)=>{
    console.log(err)
    this.setState({errorMsg:err.message})
})
}
// this helps use the constructor() for class setup


////////////////////////////////////////////
// alternate state initializing
// we can also refactor state obj to work outside the constructor()
// by defining state out side the constructor() we can use it by it self
// ie instead of this.state = {}, when using state with no constructor, jst use 'state = {}' with out the this keyword.
// NB in javascript class with out constructor will always get a constructor() still. this happens by default.
// by setting state = {}, our constructor still gets created as usual.

// but babel adds som specialty to it. if comp has no constructor() and state is initialized. babel will also call super() and props for use in the default constructor 
// and super() is still called to inherit from react class.
// it just makes us write less code


//////////////////////////////////
// passing state as props
// if we have a stand alone comp that we need in the App as a prop.
// 1. we import the comp from the file.
// 2. we put the component in the render method. to show its content.
// 3. pass props as usual and consume as usual.
// ie <Comp {this.state.property}/>


// tips:
// always extract logic from the compponent as much as possible.

// we can also make use of the tenary operator.
// we can also use temp literals inside interpolation sintax

// but instead of using teneray ops we can use a configuration object for the component

//////////////////////////
// styling in react. 
// create separate file with .css extion
// import './FileName.css' into the component module that you want to style

// use className to target elelments for styling.
// class name for container dive should be the same as name of component


////////////////
// default props
. this a method for component. it snot part of the param
// its a method. 
// its and object{}
// comp.defaultProps ={
    nameOfProp:'default value'
}
// its use in the case we fail to specify props. on the comp.
// used to specify props on very reusable component like spinners/loader


/////////////////////////
// avoiding conditional logic in render()
// when developing apps, we may need to render content:jsx,css. no matter the condition.
// i.e we may need to wrap all jsx in a border with color. and adding that to every single contional will be repetitive.
// so if we have conditions in render(), its best to isolate the condiotional jsx into its own function. 
// the render the very generic content.


//////////////////
/// pics project

/////structuring projects.
// create comp folder in the src.

//  for all including app- because when we start using redux. the index.js will containt setup code. and mixing setUp code with component code can look messy , so try as much to isolate comps from index.js.

// export comps and import into index.js


///////////////////////////////////////
///// handle user input
// how do we handle user input to our app

//////////////////////////////////////////////
STEP 1
////---:we need to get user input. ie. search bar
//create input class(form,searhBar etc. what ever requires user input)
//create html text input element. 
//form of Type input. 
// creating eventhandler:
// i: create a method on the classComponent that will act as a callback method to do something when the desired event is emitted. this method is the function that will be called when an event is fired off in the client side.
// ii: the method recieves a param, the first arg: which is (event): events is an object that holds details about the event.
// iii: when listening to event for user input. the 'event' object(arg1) passed into our method has the target.value and other event properties, this holds the value we need to get from the user
// iv: for the event to be fired off we need to attach a listener to the jsx element that the input would be passed into. once listener is set up we then pass in our method as a callback to the event listener. because its a callback we do not need to call the function, like this.eventMethod() is wrong
i.e onChange={this.eventMethod}
// events listeners work as props, special props. ie. onChange, onClick,onSubmit

N.B:- not all event listeners work for some jsx elements.ie: the onChange&onSubmit listener is not avaible of divs, because divs dont change, or submit

// alternate EventListener jsx syntax
onChange={(event)=>{single line of code}}, this is for one liners.

// controlled vs uncontrolled component
// controlled-: refactor component, create a state obj with a prop.
// in the method, once event is fired off, add the target.value to the state, create additional 'value' prop on element and pass in the value of the property in state object into it

///// what exactly is an controlled component?
what happens in our code?
1. user gives input
2. callback is called
3. we update state with the value from the user input.
4. because we update state with setState the component rerenders.
5. we then pass user input into the value prop. value attributes in htmls hold the initial input value which is then overriden by user input. because we store the uservalue in state and pass same uservalue to value attribute, the initial value will always be what the user passed in. its a cycle.

// we follow these steps because. the value is stored in the dom event obj. and any time we want the data we reach into dom:e.target.value. to get the value. but with the controlled step. we store the user input in the state then update the value prop with the input stored in the state object
// this does nothing more than giving react total control over a componenets data. 
// controlled concept, this makes react the primary driver for any data on our app.

// handle form submital
// 1. attach the onSubmit EventListener to the jsx form elelment so we can handle form submital

// N.B- prevent the default page load. this is the default behavior in the browser,when enter is pressed the page reloads because it tries to submit the form automatically. its a default behavior : use e.preventDefault() to prevent page reloads

// 2. create a callback method, to do somthing once submit event is fired off.  call e.preventDefault() in the callback method.

///////This in javascript.
// when using 'this' in react. javascript refers to 'this' as the object that it is called on.
// so how is this used in a function: because this in javascript refers to the object that it is called on. methods or functions on objects will refer to the object that called the method.
// for short: this points to the left side of the '.' operator, ie
class being{
	constructor(species){
  	this.species = species

    // binding the this to the class
    this.getSpc = this.getSpc.bind(this)
  }
  getSpc(){
  	return this.species
  }
}

const creature = new being('human')


let alien = {
	species:'glibGlops',
  getSpecies: creature.getSpc
}

alien.getSpecies()

alien.species is actually glibGlops. the 'this' calling the getSpc method is now, the alien object. the left hand of the '.' is the reference for this, now alien is the 'this'
// this can cause bugs in javascript. because it basically means 'this' can be overridden by another object.
// 'this' is loosely bound to the class, and makes overrides possible.

one way to fix the bug is to bind the function to the class it self. it binds 'this' to the class to prevent overides by another object
this.getSpc.bind(this)
another way is to use arrow functions,  because arrow functions dont have a this keyword
// for short if you are to use events in react, create the event callback with an arrow fucntion, this way this always points to the class this

//////////////////////
// communicating child to parent
// props are normally passed down to children,
// but sometimes we may need to send props up to the parent.
// we do this indirectly. 


// create object or method in component, we then pass it as a prop to the child component, then from the child we can update the prop object or call the method with the arg gotten from child. this.prop is the way to access prop obj on a class.
// basically by using objects or methods to initialize a prop in the parent and passing it to the child, we can now reassign the prop value to a value gotten in child. and then use it in the parent. we can use objects to also store data from the child in the parent.

// note:- props in component are ordinary props, while some props in jsx are special props, ie the prop onChange on a component is jst a property nothing more, however onChange on a jsx elelment is a property that is used as an event listener, we are fully in control of props on our component but not in jsx. 



///////////////////////////////////////////
STEP 2
// how do we fetch data from api
--2 make outside api calls to fetch data
making network request or ajax/api calls is not the job of react.
to make ajax calls we need to make use of a ajax client this will eneable us to request data from remote servers.
ajax clients like fetch and axios. we will make use of axios to make the network requests.

axios for get request. the get method has two args, the api we request data from, and an object for crafting http req object. we cant craft it like a complete http req object. httpreq:{
    Param:{query:'query field'},
    header:{
        Ath:'some key'
    }
}


// using async with promise like function. this is use to wait for results to return.\
// if using async await update state in asyn fucntion
aFunc = async()=>{
    try{
        let result = await do something
        this.setState({value:result})

    }catch(err){
        return err
    }
}

// note if we are expecting a particular type of data set the default state val to the datatype.
if we expect text, then state.property = ''
if we expect int, then state.property = 0
if we expect array, then state.property = []
if we expect object, then state.property = {}

// create axios default client
this is how to create a preconfigured axios instance.

axios.create({
    baseUrl: 'http://localhost',
    headers:{
        Authorization: 'Basic auth'
    }
})

how to use instance.

axios.HTTPmethod('urlEndPoint',{
    params:{
        query:'value'
    }
})


//////////////////////////////////////////////////////////////////
STEP 3
// how to show list of records
--3 display data returned from api ie list of images
create module for image display. a component. import component into root comp(app). pass data to component as prop so we can display it.

// use map method to loop over array of data and for each elelment in array, wrap it with a div/desired html element

ie newArrayOfData = arrayofData.map(data=>{<div>data</div>})


use of keys in list. keys are a special props in jsx. this helps tell react what it needs to render. ie. if we already have a list of data rendered in the dom already, but a new data needs to be appended to the list. now instead of react rerender the whole list just to include the new data, we can specify key to help tell react 'look there are already elelments in the dom with key 1,2 and 3. so only add the data with key 4'

keys are unique identifyers for elements. keys can be numbers,strings,regExp

keys should be assign to parent element. ie
<div key="1">
    <img/>
</div>

implement keys in jsx


/////////
reach into dom to get data.
// when we want to get details of a dom elelment in react we use refs.
// in js we use document.querySelector(), but in react we make use of the ref system
// react refs(reference) gives us direct access to a single dom element displayed.
// we initialize refs in the constructor function just like state. we then pass the dom elelment into the refs. 
// we can pass the dom elelment into state, but refs do not change over time. state is used for data that changes overtime


// how to create ref.
// init in constructor
// assign them variable names, vars should call store react method(react.createRef) the result value enables us to the create refs.

//once created pass them into target jsx elelment, use the ref prop.

ref={this.refname}
ie. 
constructor(props){
    super(props)
    this.nameOfVar = react.createRef() 
    this.state = {height: null}
}

render(){
    return(
        <div ref={this.nameOfVar}></div>
    )
}

/// image card 
// let image card render its self and its images.
// get elelment data from dom(height data)
// set image height on state
// update grow grid row end on css based on the height of each image. dynamically set.


// a jsx element, will eventually become a dom element, but befor then its jst a jsx tag. the ref gives us the details on a dom element. in other word, before we can get data on an element, the element has to be in the dom, basically it has to mounted in the browser and converted to html.

// note this process can be asynchronous. in the case the element is depending on an external api call. (async await wont work) so we should use callbacks to get data asynchronously. for callbacks we need an eventListener, to listen for an event that would trigger the callback.


// test.
// create app.
// video app component break down
// search comps, video list comp, video card comp, video player comp

////////////////////////
// how to use ifram.
// ifram element are html elements for playing videos. this element can make api calls to external services(on its own)
// get the embebd link from youtube, replace the id part with the id from state.

const VideoDetail = ({ videoDetails }) => {
  const i_d = videoDetails.id?.videoId;
  const vidSrc = `https://www.youtube.com/embed/${i_d}`;
  const { snippet } = videoDetails;
  if (!Object.keys(videoDetails).length) {
    return <div>loading...</div>;
  }
  return (
    <div>
      <div className="ui embed">
        <iframe src={vidSrc} title="videos" />
      </div>
      <div className="ui segment">
        <h4 className="ui header">{snippet.title}</h4>
        <p>{snippet.description}</p>
      </div>
    </div>
  );
};

//////////////////////////////////////////////////////////////////////////////// react hooks
hooks system gives us the ability to make fully usefull func components without using classes.
// it simulates the state system in ClassBasedComp(CBC) with useState functions
// it simulates the ref system in ClassBasedComp(CBC) with useRef functions
// it simulates the Lifecycle methods in ClassBasedComp(CBC) with useEffect functions

// *with these primitive hooks we can create costum code to perfom repeated tasks. 

// react fragments let you wrap up jsx like div,but the react fragments arent added to the dom, but the div is.



///////////////////////////////////////////////////////////////////////////////////
// use state is a primitive react hook for FCs (functional components)
it gives us access to the state system with out using ClassBasedComps
// useState(): functional state sytem
// to set state import the useState fucntion from react.

with the array destructuring syntax [], [valueName,setvalueNameFn] = useState(null), this is to initialize the state system.

// in the array the first var in the [] syntax refers to our state property(the one whos value is to change over time). the second var in the [] syntax is a setter function that when called will update our state and rerender the app, just like this.setState({}) in ClassBasedComp

// the useState(), is a function that is used to initialize our state.

// it takes one arg which will be the default or initial value for our state property.

then to update state use setvalueNameFn(valueToSet)(setterFn)

then to reference state values use {valueName}

this process is needed to use every piece of state. if we need 3 different pieces of state we do this 3 times


// step 1 
let [value1,setValue1Fn] = useState(null)
let [value2,setValue2Fn] = useState('')
let [value3,setValue3Fn] = useState(0)

// step 2
setValue1Fn(10)
setValue2Fn('stringVALE')
setValue3Fn(5)

// step 3
h1 {value1}
h1 {value2}
h1 {value3}


/////////////////////////////////////
//// useEffect() hooks
// allows FCs to be able to use something like lifeCycle methods on classBasedComponents.
// useEffect is configured to run in 3 different scenarios.

1. When the component is rendered for the first time only. like comp did mount
2. When the component is rendered for the first time and when ever again it rerenders.
3. When the component is rendered for the first time, when ever again it rerenders and when ever some piece of data has changed


// use useEffect(),
1 import {useEffect} from react

const Funccomp = ()=>{
    useEffect(()=>{
        doStuff
    })
}

// use useEffect and configure. 
2. useEffect() takes two args. the callback that useEffect() should run and in the scenerio were useEffect should be called.(any of the 3 stated above)
1. When the component is rendered for the first time only.
useEffect(cb,[])

2. When the component is rendered for the first time and when ever again it rerenders.
useEffect(cb)

3. When the component is rendered for the first time, when ever again it rerenders and when ever some piece of data has changed.
useEffect(cb,[pieceOfData])

let [x,setX] = useState('')


cant mark useEffectFn as async, 
this wont work
// useEffect(async()=>{
    let result = await some Stuff
    setX(result)
},[x])
but can use async in a function nested.useEffect()
this will work
useEffect(()=>{
    //create function
    let somePromise = async()=>{await some stuff}
    //call function
    somePromise()

    //ie2,immiediate executables
    (async(){
        await some stuff
    })()

    //ie3 use promise then.catch() methods 
    Promise.resolve().then().catch()
})
// in the useEffect function the only value we can return is a function. this function is used by react when ever useEffect is called(either of the 2 continous scenarios(useEffect(()=>{}), useEffect(()=>{},[state]) ))

// the function serves as a cleanup/maintainance fn to do or set something when ever useEffect is called. after the first call the returned function wont execute(because its the firsttime), but the second time and onward its then called by react and it will be executed before the callback passed into useEffect().
// i.e
useEffect(()=>{
    2. // do something

    1. return ()=>{
        // do some other thing
    }
},[state])

// useEffect() warnings
the depency warning happens when we reference a piece of state that is added into the second arg.
// the useEffect requires any state referenced in its scope to be in the second arg.

useEffect(()=>{
    console.log(state)
    console.log(someState)
    console.log(someOtherState)

    // like this any state referenced should be in the array
},[state,someState,someOtherState])

// this can cause bugs, because useEffect would rerender anytime either of the pieces gets updated, that mean multi uneccessary function calls, or api calls, or numerous operations.

////////////////////////////////////////////////
wiki Api
en.wikipedia.org/w/api.php?action=query&list=search&format=json&origin=*&srsearch=programming

// turn a html text to jsx, if we recieve html as a response, we can convert html text to jsx. but it is risky. because malicious javascript can be executed(xss). 
// use <element dangerouslySetInnerHTML={{__html:html text}}></element> 
// this leaves use open for xss attacks.


////////////////////////////////////////////////////////////////////
// event bubbling.
// to understand this we need to understand what happens when an event get fired of in an elelment.

// there are three phases that the event goes through
// 1. capturing phase.
// 2. targeting phase 
// 3. bubbling phase.

// (caputuring)first when an event is fired, the browser creates an event object it then passes it to the top most parent element(body tag), the event starts from the top most parent element, and then it travels down the dom tree.
// second as the event travels down the dom tree in the capturing phase the event would then stop at the target element(the element that fired the event) and then execute the callback attached to the listener(targeting)
// third after the listener callback is executed, the event than tarvels back up the dom tree, back to the top most parent element(bubbling). back to its origin.

// now note that as the event travels up and down the dom tree, if another element is listening for the same event it will also be executed.

<div onClick={}>
    <h1 onClick={}></h1>
</div>

both the div and h1 element have the onClick event listeners attached to them. if the h1 is clicked, 1st the callback on the h1 will be executed, then as the event goes up the dom tree it would also stop at the div and execute the callback attached to the div elelment onClick listener too. this is the bubbling, the event can also be executed dowards in the capturing phase.

// in the target phase, the are two properties on the event object.
// 1. the target
// 2. the currentTarget

// the target points to the element that fired the event. the target does not change as the event bubbles up. ie, if the h1 fired the event it will be the target, even when the event reaches the div the target remains the same(h1), but the currentTarget will change based on the other elements that listens to the event.

//NB in react we can set manual event listeners using dom api. document.body.addEventListener()

// dom api addEventListener()'s have some sort of precedence over react event listeners. this is means dom event listeners will get executed first before react event listeners.

//useRef
// ref is used to get an object containing information about a soecific element.
// useRef is quite simple to use. 
// step 1 import useRef jsut like useState, useEffect
// initialize useRef and store in variable.
// ie, let ref = useRef()
// pass ref variable to the target element ref prop.
let component = ()=>{
<div ref={ref}></div>

}

// nb the element's detail object stored in the ref variable, it's only avaible if the component displaying the element exist in the browser's dom.
// i.e if the component containing the div is no longer in the dom/ or body element the ref variable will be undefined, meaning the detail object for the element(div) will no longer be stored in the ref. this can cause some bugs in the app. for exeample when we refer to the ref variable and its undefined, it will raise a error.

1
// solve this bug by using optional chaining, ie. ref.current?.property
exaple ref.current?.contains() if thid method is called an ref is undefined then it wont raise the error.

2
// we can also remove the eventListener from the dom. in the useEffect return fn


///translate api key 
AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM

//////
// navigation.
// basic. this type of routing is basic. it makes use of the window.location object, in the object there is a pathname property. it specifes the current route ie. pathname of 127.0.0.1/:3000/aPathName, will be '/aPathName'
//with this value we can create a function that conditionally returns a component based on the pathname property.

if(window.location.pathname === '/items'){
    return <Items/>
}


/////////////////////////////////////////////////
// customhooks
costum hooks do not mean we are to create a new hook, like make our own useEffect hook, NO!. custom hooks is just a way to make using hooks and component logic more reuseable. this does not refer to jsx in the component. this means the basic logic of the component. ie like fetching data to update state and to rerender app when state has changed. costum hooks are made to make use of primitive hooks more reuseable.

// 4 step process to create costum hooks
// 1. identify the purpose of each line of code and how other pieces of code relate to it.
2. identify the required input for the function to work with.
3. identify the needed output that the function should return.
4. extract all the code into a separate function that recieves the input and returns the output.

//////////////////////
// deploy react app. 
// react app is baically a bunch of static files(files that can be stored in a folder)
// it doesnot require a vm to host because it doesnt need a server to execute code.
// it is afffordable


////////////////////////////////////////////////////////////////////////////
//// redux lib
this library is made to make state management in apps easy. it is not specifically for react but it will help a whole lot when building react apps. 

// redux stages.
1. action Creator- this is like initialize an object.(in the redux analogy of the insurance company, action creator is like the user briging in his signup form or claim form, he creates the form(action))

2. Action- this is the object(form) it self. it contains the type, and payload(in the redux analogy of the insurance company, action is like the form and its purpose, either to sign up or to make a claim)

3. dispatch- this is a function that makes copies of the object(form) and distributes it to specific places in redux(in the redux analogy of the insurance company, it is like the front desk personel that takes the form and hands it out to the departments)

4. reducers- this function takes in the action(form) objects looks at the type and updates its data. it is like little slices of state. concerned with only the data useful to it.(in the redux analogy of the insurance company, when the departments take in the form and processes it, ie. the polices dept will take in the sign up the user and update the storage book of users to include the new user)( // in reducers avoid modifying existing data Structures, intsead create new one, and always return a value). reducers takes a piece of state modifies it based on the action and returns the updated piece of state. reducers accept accumulation and a value and returns a new accumulation. it reduces a list of values into a single value.

5. state- this stores all the reducers(little slices of state to make a whole state) data. (in the redux analogy of the insurance company, where all departments data is stored)

// redux :
combineReducers: creates an object which stores a comnination of all our reducer functions.
createStore: this is the main redux function. the store represents our state and it reducers and a dispatcher for dispatching actions to be handled by our reducers.

redux flow summary:
// to update the state with redux
1 actionCreates action
2 action gets fed to dispatcher
3, dispatcher makes copies of the action(obj) and sends it to all our reducer functions
4 reducers update state based on the action(object) conditions, and passes new data into general state object

5 the general state object holds all the updated state and it waits for future updates to state

// only modify state with a store disatcher and an action, we cant modify them directly from the reducers of the combineReducers function. only update state from the store

// new project
start new project songs
import redux react-redux

do basic app clean up and settings.

// react uses state to store and update pieces of state.
// in redux we use reducers instead, reducer kind of work like the react useState(), it holds the state and has the function to update the state like its own setState() function. reducers is a function it self, it holds the state and accepts an action that will tell the reducer how to change the state.

// the action creato fn is meant the give us an action that we give to the reducer.

///////////////////
/// react redux
// provider componenet- the provider comp is a component avaible on the react-redux lib, the provider is meant to parent all our app components
, 1st by wrapping the App component(like providing our App as a comp prop to the provider)
// the provider accepts the redux store(dispatcher,reducers and state) as a prop. and this makes the store also avaible to our App comp
ie. <Provider store={createStore(CombinedReducers)}> <App/> </Provider>

// connect component- the connect comp is a component avaible on the react-redux lib, the connect is a component that works hand in hand with the provider, the provider holds the whole redux store, but the connect doesnot. so react-redux makes it possible for the connect comp to react into the store and grab the state. 
i.e the whole purpose of the connect comp is to get the store from the provider  and pass it as a prop to any child comp that needs it

// make use of connect. 
1, create a fucntion, this function is made to accept the state that the connect brings from the provider. mapStateToProps = (state)=>{return state}

2. after creating the function, pass it into the connect comp as an arg
i.e- connect(mapStateToProps),

3. after passing in the function argument to connect when connect gets invoked it returns another function that accepts the component that needs the state. this will then make the state avaible in our component.
i.e- connect(mapStateToProps)(aComponent). like this


// mapStateToProps- function that wil recieve state from provider and pass to specified Component, and tells our component any time state changes

// react-redux makes use of dispatchers in a way that the developer wouldnt call it as usual in a redux app. instead the actionCreator is passed as a second arg into the connect fucntion. nb actionCreator should be wrapped in an object
ie connect(mapStateToProps,{actionCreator})(aComponent) 
// just like connect makes state avaible it also makes dispatchers avaible by passing in the actionCreator as the second arg

// visit jsonplaceholder api, go to resources

/// make api call in redux app

// redux async errors: creating async actionsCreators
Error: Actions must be plain objects. Instead, the actual type was: 'Promise'. this error comes from returning special(request Objects) objects in an actionCreator. redux uses Plain Objects so return any thing other than plain objects will cause the above error 

also error can arise from async awaiting api calls. under the hood the async function will returns a response object and not a regular object.
and if we do not use async await we get a promise. but our action creator and dispacther and state update is very synchronous in execution, this means before promises are settle state is already updated. we need a way to wait for the async ops to complete before updating state. to avoid this race condition, we make use of middlewares
, this are regular functions that sit between the dispacther and the reducer. so instead of actions to be dispatched into reducers synchronous, the middle stands between them. the middler can manipulate the action in many ways before sending the action to the reducer to update state.

// a common middle ware is redux thunk. redux thunk is used as middleware function. it works when action are functions and not objects. when actions are functions redux thunk calls the function and adds a dispatcher and getState funcs as args to the function which makes it possible to manually call the dispatch fucntion and getState

// wire up middlewares 
// with the help of the redux applyMiddleware function we can wire up middlewares to our apps.
// use applyMiddleware function as the second argument to the createStore function. ie createStore(reducers, applyMiddleware(thunk))

// async await can now be used with redux thunk with out errors. redux thunk is a middleware and doesnt directly return anything to the reducer. instead we are the ones who dispatch the action object manually, so we can wait for async ops to complete and then return an action object.
ie fetchData = () => {
  return async (dispatch,getState) => {
    const res = await jsonplaceholder().get("/post");
    dispatch({
      type: "API_CALL",
      payload: res,
    });
  };
};
