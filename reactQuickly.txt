// used for displaying components

// in these five steps
// 1. import react lib dom 
// why two libraries?
// react understands and reads components and how multiple components work together. cant display components in the browswer
import React from 'react'

// react dom understands how to get components to show up in the browser
// converts jsx to html
import ReactDOM from 'react-dom/client'

// 2. hook onto html elelment with root id
const el = document.getElementById('root')

// 3. take control of the elelment
// tell reactDom to show are app in the browser 
const root = ReactDOM.createRoot(el)

// 4. create a component
// functions to return jsx
// eg.1
// let App = ()=>{
//     // display js vars in jsx
//     // create var: vars can be of any data type but know that react cant render bool. so all dataTypes i.e string Nums bigInt symbols etc, but not true, false, null and undefined 

//     // datastructures for vars in react. array elements gets smushed into one value, and objects are nit valid react children
//     let variable = 'hello world'
//     let name = 'david'
//     // use of conditionals
//     if(Math.random()>0.1){
//         // change var based on condition
//         variable = 'hello guys'
//     }
//     // use interpolation{} to return a js var or an expression
//     // {} can also be used like template literals. for running pure js expressions. cant mix values in {}
//     return(<h1>{variable}. My name is {name} and the time is {new Date().toLocaleString()}</h1>)
// }
/////////////////////////////////////////////////////////////////
// eg 2
// costumize element with props
// let App = ()=>{
//     // input
//     // props is short for properties. 
//     // we use props to costumize elements in jsx.
//     // we can use js to specify props to be referenced inside elements
//     // props can be of string and numbers, but of also arrays and objects
//     // arrays and objects are to be wrapped with curly {} jst like numbers
//     let arr = [1,2,3]
//     let obj = {color:'red'}
//     let mins = 5
//     return(
//         <input type='number' max={10} min={mins} style={obj} list={arr}></input>
//     )
//     // when specifiying props directly on elements. if string wrap with "number", if number wrap with {3} 
// }

////////////////////////////////////////////////////////////////////
//textArea auto focus doesnt work in jsx how it does in html
// convert html to jsx in 5 steps
// 1. all props follow camelCase, maxlength is now maxLength 
// 2. props meant for numbers should be wrapped in curly braces{4},maxLength={4}
// 3. probs meant for booleans should be wrapped in {}, in case of 'true' there is no need to specify true. ie spellCheck, but if false specify it in {}, spellCheck={false}
// 4. in jsx className is the same as class in html. classes are used in styling for css. jsx is written in javascript and class in js is a keyword
// 5. in jsx inlin css styles are in objects. properties are specified with camelCases. ie padding-top is paddingTop

let App = ()=>{
    let csss = {
        border:'6px solid red',
        paddingTop:'100px'
    }
return(<textarea maxLength={5} autoFocus={true} spellCheck={false} style={csss}></textarea>)
} 

// 5. show the component on screen
// display component with root(the element react has taken control over)
// element.render(<component />)
root.render(<App/>)

jsx is important. it makes structuring the app easier. Easier to read to

in using the old react.create element. Once the code base grows the code brcomes harder to read and to avoid bugs.

ie what do elements do. jsx doesnt auto appear in the browser. it just tells react what elements to create. for jsx to appear in the browser we need to use the return keyword

////////////////////////
three tenets of components-design

1. nesting- show a component inside a components

2. reusabilty- components that we can use over and over again without rewriting the component. ie) buttons do the same thing. Show some text and do something when clicked. components are basically little pieces of code for that can be reuse in many diff apps

3. Configuration- config components when they are created- even as components can be reused(buttons etc). we should still be able to add some costum features to them.


////////////////////////////////////////////////
steps to create reusable components
step.1 identify jsx that is duplicate. components follow the dry principle. we write code once but reuse it in multiple parts of the codebase rather than writing similar code every time we need to perform the same operation over and over again

step.2 once duplicate jsx is spotted we try to isolate the code and give it a very discriptive name in relation to its purpose. ie if we have a jsx comment component and we dupicate the jsx to produce multiple components. we should instead  get the comment jsx and and turn it into a stand alone comment component 
like so const CommentDetail = ()=>{return()}

step3. once jsx has been made into a stand alone component. the next thing to do is to send the component to its own standAlone module. the module file should be named after the component. ie. CommentDetail.js should hold the CommentDetail component

step4. Once file is created move the jsx component to the file. 

step.5 make the components configurable with props. if parts of jsx are hard coded when it should be dynamic. use props to make it costum. like do not hard code dates, user names etc they should be dynamic


////////////////////////////////////////////////
nesting components
steps to render nested component
step1. export component from component module
step2. import component module into app or index.js.
do not use interpolation to render, that is for js vars. Instead render 
component like so <Component />

/////////////////////////////////////////////////
understand component hierachy

////////////
props for properties
props sysytem- systems for passing Data from the parent component to the child components. this is what makes components dynamic and costumization. think of props as js vars that look like html attributes. this props make componenets more dynamic. childrren cant pass props to parents directly

visaulize app like an object
// one istance of app. the app holds the children. App is the parent
// the children are inside app. the need to be in app to be rendered.ie-CommentDetailz

let App = {
    ApprovalCard:{
        CommentDetail:,
    }
}

//////////////////////////
passing props
there are two stages for using react props system.
// 1. passing the props down
// 2. consuming props passed down

when passing down props or providing props. 
1. we specify props in the component tags. <Component NameOfProps='Mr.propsMans'/>

2.props names should make sense in relation to the Component features
ie authorOfComment='Name'

3. props are unique to the component instance it was specified in
<Component ThisIsMyProp='iDontLikeSharingMyPropsWithAnyone'/>
<Component ThisIsMyVeryOwnProp='iDontLikeSharingMyPropsWithAnyoneToo'/>
<Component ThisIsMyVeryOwnPropJstForMe='meToo'/>

when consuming props. with child

when consuming props.
1. the first arguement for the component(the funct that returns jsx) is meant for the props obj. we get access to it if specified as a param in the component

2. use interpolations to insert into jsx. its basically javascript values. again use {props.someShit}

3. they work like varaibles in js

4. props can be passed into jsx elelments || html attributes like src ,href, className etc

let  Comp = (props)=>{
    return(<div className={props.AclassName}>{props.someData}<div/>)
} 

///////////////////////////////
passing multiple props
we can also pass multiple props into components
<Component 1Prop='meIam1' 2Prop='meIam2' 3Prop='meIam3'>


//////////////////////////////////
components reusablity
@TODO: Approval card. to practice reusable component.
1. create reusable component. create standAlone component with its own module file

////passing components as props
1. we can pass props as attributes in jsx 
2. but to pass a component as a prop we insert it between the component tags
i.e <ReusableComponent> <PropComponent/> </ReusableComponent>
3. comsume comp props as usuall (props)=>{}
4. component props are inside a nested children object.
5. consume props with interpolation <div>{props.children}</div>

///////////////////////////////////////////
class based componenets
- what are class based comps
1. class based components still serve the same purpose which is to return jsx.
2. but it can do more. class comps gives us abilty to use react Lifecycle methods. more on this laterOn.
3. also give use access to react state sysytem. to update content. more on this laterOn

// diff between class and function comps.
// early react used functions to only return jsx. functs cant use state sysytem or Lifecycle. was strictly for showing content. 
// but now react function component has Some thing called the hooks sysytem. more on this laterOn. but know the hooks gives functions the abilty to run code at specified time and gives functs access to react state system


// seasons app scarfold

// App comp. this takes in user data. to pass down to child
// seasons comp. this consumes data and renders text and icons based on data it recieves


// get user location. 
// the navigator Api can be found in the window object.
// we use the api like. window.navigator.geolaction.getCurrentPosition(Resolve CB, Reject CB)
// resolve cb f(n) runs when its succesful and the Data is return.
// reject cb f(n) runs when its unsuccesful and an err is return

// what happens in the app (fucn)
// browser loads js file- browser reads the file andd creates the app components. and invokes the component functio calling on the geoloc api
// once app is created. the browser calls the goeloc api
// app returns jsx instantly.
// the process is very synchronous. so any asynchronous operation will work if the app is rerendered

// the geoloc sevice is promised based. it takes some time to run and get data. before then the rest of our code already executed.
// we need away consume promise based operations

// refactor func to class
// rules to make class comps
// use js classes, Extent the React.Component class(inherit some features)
// must define a render() method that returns some jsx:so if you want the browser to display the content, we need render to return jsx.
// construction(). this fucn is important create instance of a class.
it is the very first fucn called when we create instances of a class. this makes it a good place to initialize state. 


// ///////////////////
state system in react
//1. helps with async operations in react
//2. updates and rerenders the app


// rules of the state system
// 1. only usable in class components
// 2. props can be confused with state
// 3. State is a js object that holds data relavant to a specific componnent. the data Obj is strictly revelant the component we are working one. ie. the will a specific state Obj for our App component
// 4. updating data in state. will instantly(almost) make our comp rerender.
if we want a our comp to rerender we must update state
// 5. state must be initialized once component is created
// 6. state can only be updated with setState() functions

// initializing state in class comp
// with the constructor(). this func is important because at any point the comp is instanciated the function will always be called. because it is called first its a good place to initialize the state.

// jst like the func comps the class comp also makes use of the props system. to pass data
// call super() funct. this func gives us access to the parent class functions and methods. because our class extends React.component class. we call super() for our class App has access to React.Component class funcs and meths
// call super(props)

// after adding the constructor func and calling the super(props) func, initialize state with an obj. the this KeyWord is a reference to our class(which is basically an object). so this.state = {}, also means ourClass.state={}. this enables us to refer to different methods and properties. in our class.

//e.g  constructor(props){
    super(props)
    this.state={}
  }

  ////////////////////////////////
  update state with props
  // because the state is initialized, we can access the state and its properties using this(remember this is a pointer to our class)
  // this.state.property

  // in the render funct we try not to perform long operations. this is because the render funct will get called many times. so to avoid running the same task over and over again. take long operations out of the render funct

  // update state and rerender
  // use setState() to update state. we pass in an obj as a param which will represent our state. setState({}), in the object we then set the property we needed to update.
  // i.e setState({property:'value'}). i know you are thinking if this.state.proptery = value would work. it wont, infact thats a bad idea.
  the only time we do a direct assignment is when initializing the state obj in the constructor, this.state={}. so in other words use setState({})



  ///////////
  // app life cycle summary.
  // js file is loaded in browser.
    - the browser read and runs our js file.
  // instance of App is created
    - the instance of our class app is created. because we use the constructor we have to use super to avod errors

  // state object is created and initialized. the state must be 'state' to work.basically assign an obj to state

  // we call the geoloc service. its a promise
  // react render the comp

  // then the geoloc promise is returned

  // the setState rerenders the app with new data


  /////////
  // error handling.
  // handle errors gracefully
  // create an error property in state. and update the property if error occurs.
  // this.state = {error:''}
  // if error ecountered. use setState({error:'error value'})
  // nb, when using () with the return statement. return() avoid using semicolon. ;. this ends a js statement. and cant return a block of jsx


///////////////
// conditional rendering
// you  can use if blocks to render conditionally.
// if(this.state.error){
    return(<div>error: {this.state.error}</div>)
}
// if(!this.state.property){
    return(<div>cant find data</div>)
}
return(data)


////////////////////////////
// Lifecycle methods
// these are optional methods given to us by react.
// if we use them. the methods would be called at certain times in a componenets life cycle.

class App {
    //1
    constructor(props){
        //1b
        super(props)
        //1c
        this.state={}
    }
    //2
    render(){show content}

    // life cycle methods give us the ability to perform certain operations at various stages in a components life cycle.
    componentDidMount(){
        // this is called as soon our app gets mounted in the browser. as the jsEngine reads our files and creates our app. this function is called.
    }
    // after being mounted our app sits around and waits for updates to the state obj
    componentDidUpdate(){
        // this func is called anytime our component is updated.
        any time setState({}) is called this func gets called
        // and anytime componentDidUpdate is called. the render methods is also called. and the jsx is return with the updated values
    }
    componentDidUnmount(){
        // this method would be called when our app is unmounted and no longer loaded in the browser
    }
}

// use like so
componentDidMount(){
    
  }
  componentDidUpdate(){
    
  }


////////////////////////////
// why LCM(life cycle methods) 
// didMount: used for initial app setup, dataloading, outside api calls,etc
// didUpdate: used for loading data that has been updated.change in state or props.
// willUnmount. used when removing comps and cleaning up code

////////////////////////////////////////////////////
// refactoring data loading to lifeCM
// use the componentDidMount fucn to help run set up code.
// ie when using the geoloc service. we need the service to be called as soon our app has been mounted. 
ie
// componentDidMount(){
window.navigator.geolocation.getCurrentPosition((position)=>{
    let latitude = position.coords.latitude
    let longitude = position.coords.longitude
    this.setState({lat:latitude,lng:longitude})
},(err)=>{
    console.log(err)
    this.setState({errorMsg:err.message})
})
}
// this helps use the constructor() for class setup


////////////////////////////////////////////
// alternate state initializing
// we can also refactor state obj to work outside the constructor()
// by defining state out side the constructor() we can use it by it self
// ie instead of this.state = {}, when using state with no constructor, jst use 'state = {}' with out the this keyword.
// NB in javascript class with out constructor will always get a constructor() still. this happens by default.
// by setting state = {}, our constructor still gets created as usual.

// but babel adds som specialty to it. if comp has no constructor() and state is initialized. babel will also call super() and props for use in the default constructor 
// and super() is still called to inherit from react class.
// it just makes us write less code


//////////////////////////////////
// passing state as props
// if we have a stand alone comp that we need in the App as a prop.
// 1. we import the comp from the file.
// 2. we put the component in the render method. to show its content.
// 3. pass props as usual and consume as usual.
// ie <Comp {this.state.property}/>


// tips:
// always extract logic from the compponent as much as possible.

// we can also make use of the tenary operator.
// we can also use temp literals inside interpolation sintax

// but instead of using teneray ops we can use a configuration object for the component

//////////////////////////
// styling in react. 
// create separate file with .css extion
// import './FileName.css' into the component module that you want to style

// use className to target elelments for styling.
// class name for container dive should be the same as name of component


////////////////
// default props
. this a method for component. it snot part of the param
// its a method. 
// its and object{}
// comp.defaultProps ={
    nameOfProp:'default value'
}
// its use in the case we fail to specify props. on the comp.
// used to specify props on very reusable component like spinners/loader


/////////////////////////
// avoiding conditional logic in render()
// when developing apps, we may need to render content:jsx,css. no matter the condition.
// i.e we may need to wrap all jsx in a border with color. and adding that to every single contional will be repetitive.
// so if we have conditions in render(), its best to isolate the condiotional jsx into its own function. 
// the render the very generic content.


//////////////////
/// pics project

/////structuring projects.
// create comp folder in the src.

//  for all including app- because when we start using redux. the index.js will containt setup code. and mixing setUp code with component code can look messy , so try as much to isolate comps from index.js.

// export comps and import into index.js


///////////////////////////////////////
///// handle user input
// how do we handle user input to our app

//////////////////////////////////////////////
STEP 1
////---:we need to get user input. ie. search bar
//create input class(form,searhBar etc. what ever requires user input)
//create html text input element. 
//form of Type input. 
// creating eventhandler:
// i: create a method on the classComponent that will act as a callback method to do something when the desired event is emitted. this method is the function that will be called when an event is fired off in the client side.
// ii: the method recieves a param, the first arg: which is (event): events is an object that holds details about the event.
// iii: when listening to event for user input. the 'event' object(arg1) passed into our method has the target.value and other event properties, this holds the value we need to get from the user
// iv: for the event to be fired off we need to attach a listener to the jsx element that the input would be passed into. once listener is set up we then pass in our method as a callback to the event listener. because its a callback we do not need to call the function, like this.eventMethod() is wrong
i.e onChange={this.eventMethod}
// events listeners work as props, special props. ie. onChange, onClick,onSubmit

N.B:- not all event listeners work for some jsx elements.ie: the onChange&onSubmit listener is not avaible of divs, because divs dont change, or submit

// alternate EventListener jsx syntax
onChange={(event)=>{single line of code}}, this is for one liners.

// controlled vs uncontrolled component
// controlled-: refactor component, create a state obj with a prop.
// in the method, once event is fired off, add the target.value to the state, create additional 'value' prop on element and pass in the value of the property in state object into it

///// what exactly is an controlled component?
what happens in our code?
1. user gives input
2. callback is called
3. we update state with the value from the user input.
4. because we update state with setState the component rerenders.
5. we then pass user input into the value prop. value attributes in htmls hold the initial input value which is then overriden by user input. because we store the uservalue in state and pass same uservalue to value attribute, the initial value will always be what the user passed in. its a cycle.

// we follow these steps because. the value is stored in the dom event obj. and any time we want the data we reach into dom:e.target.value. to get the value. but with the controlled step. we store the user input in the state then update the value prop with the input stored in the state object
// this does nothing more than giving react total control over a componenets data. 
// controlled concept, this makes react the primary driver for any data on our app.

// handle form submital
// 1. attach the onSubmit EventListener to the jsx form elelment so we can handle form submital

// N.B- prevent the default page load. this is the default behavior in the browser,when enter is pressed the page reloads because it tries to submit the form automatically. its a default behavior : use e.preventDefault() to prevent page reloads

// 2. create a callback method, to do somthing once submit event is fired off.  call e.preventDefault() in the callback method.

///////This in javascript.
// when using 'this' in react. javascript refers to 'this' as the object that it is called on.
// so how is this used in a function: because this in javascript refers to the object that it is called on. methods or functions on objects will refer to the object that called the method.
// for short: this points to the left side of the '.' operator, ie
class being{
	constructor(species){
  	this.species = species

    // binding the this to the class
    this.getSpc = this.getSpc.bind(this)
  }
  getSpc(){
  	return this.species
  }
}

const creature = new being('human')


let alien = {
	species:'glibGlops',
  getSpecies: creature.getSpc
}

alien.getSpecies()

alien.species is actually glibGlops. the 'this' calling the getSpc method is now, the alien object. the left hand of the '.' is the reference for this, now alien is the 'this'
// this can cause bugs in javascript. because it basically means 'this' can be overridden by another object.
// 'this' is loosely bound to the class, and makes overrides possible.

one way to fix the bug is to bind the function to the class it self. it binds 'this' to the class to prevent overides by another object
this.getSpc.bind(this)
another way is to use arrow functions,  because arrow functions dont have a this keyword
// for short if you are to use events in react, create the event callback with an arrow fucntion, this way this always points to the class this

//////////////////////
// communicating child to parent
// props are normally passed down to children,
// but sometimes we may need to send props up to the parent.
// we do this indirectly. 


// create object or method in component, we then pass it as a prop to the child component, then from the child we can update the prop object or call the method with the arg gotten from child. this.prop is the way to access prop obj on a class.
// basically by using objects or methods to initialize a prop in the parent and passing it to the child, we can now reassign the prop value to a value gotten in child. and then use it in the parent. we can use objects to also store data from the child in the parent.

// note:- props in component are ordinary props, while some props in jsx are special props, ie the prop onChange on a component is jst a property nothing more, however onChange on a jsx elelment is a property that is used as an event listener, we are fully in control of props on our component but not in jsx. 



///////////////////////////////////////////
STEP 2
// how do we fetch data from api
--2 make outside api calls to fetch data
making network request or ajax/api calls is not the job of react.
to make ajax calls we need to make use of a ajax client this will eneable us to request data from remote servers.
ajax clients like fetch and axios. we will make use of axios to make the network requests.

axios for get request. the get method has two args, the api we request data from, and an object for crafting http req object. we cant craft it like a complete http req object. httpreq:{
    Param:{query:'query field'},
    header:{
        Ath:'some key'
    }
}


// using async with promise like function. this is use to wait for results to return.\
// if using async await update state in asyn fucntion
aFunc = async()=>{
    try{
        let result = await do something
        this.setState({value:result})

    }catch(err){
        return err
    }
}

// note if we are expecting a particular type of data set the default state val to the datatype.
if we expect text, then state.property = ''
if we expect int, then state.property = 0
if we expect array, then state.property = []
if we expect object, then state.property = {}

// create axios default client
this is how to create a preconfigured axios instance.

axios.create({
    baseUrl: 'http://localhost',
    headers:{
        Authorization: 'Basic auth'
    }
})

how to use instance.

axios.HTTPmethod('urlEndPoint',{
    params:{
        query:'value'
    }
})


//////////////////////////////////////////////////////////////////
STEP 3
// how to show list of records
--3 display data returned from api ie list of images
create module for image display. a component. import component into root comp(app). pass data to component as prop so we can display it.

// use map method to loop over array of data and for each elelment in array, wrap it with a div/desired html element

ie newArrayOfData = arrayofData.map(data=>{<div>data</div>})


use of keys in list. keys are a special props in jsx. this helps tell react what it needs to render. ie. if we already have a list of data rendered in the dom already, but a new data needs to be appended to the list. now instead of react rerender the whole list just to include the new data, we can specify key to help tell react 'look there are already elelments in the dom with key 1,2 and 3. so only add the data with key 4'

keys are unique identifyers for elements. keys can be numbers,strings,regExp

keys should be assign to parent element. ie
<div key="1">
    <img/>
</div>

implement keys in jsx


/////////
reach into dom to get data.
// when we want to get details of a dom elelment in react we use refs.
// in js we use document.querySelector(), but in react we make use of the ref system
// react refs(reference) gives us direct access to a single dom element displayed.
// we initialize refs in the constructor function just like state. we then pass the dom elelment into the refs. 
// we can pass the dom elelment into state, but refs do not change over time. state is used for data that changes overtime


// how to create ref.
// init in constructor
// assign them variable names, vars should call store react method(react.createRef) the result value enables us to the create refs.

//once created pass them into target jsx elelment, use the ref prop.

ref={this.refname}
ie. 
constructor(props){
    super(props)
    this.nameOfVar = react.createRef() 
    this.state = {height: null}
}

render(){
    return(
        <div ref={this.nameOfVar}></div>
    )
}

/// image card 
// let image card render its self and its images.
// get elelment data from dom(height data)
// set image height on state
// update grow grid row end on css based on the height of each image. dynamically set.


// a jsx element, will eventually become a dom element, but befor then its jst a jsx tag. the ref gives us the details on a dom element. in other word, before we can get data on an element, the element has to be in the dom, basically it has to mounted in the browser and converted to html.

// note this process can be asynchronous. in the case the element is depending on an external api call. (async await wont work) so we should use callbacks to get data asynchronously. for callbacks we need an eventListener, to listen for an event that would trigger the callback.


// test.
// create app.
// video app component break down
// search comps, video list comp, video card comp, video player comp

////////////////////////
// how to use ifram.
// ifram element are html elements for playing videos. this element can make api calls to external services(on its own)
// get the embebd link from youtube, replace the id part with the id from state.

const VideoDetail = ({ videoDetails }) => {
  const i_d = videoDetails.id?.videoId;
  const vidSrc = `https://www.youtube.com/embed/${i_d}`;
  const { snippet } = videoDetails;
  if (!Object.keys(videoDetails).length) {
    return <div>loading...</div>;
  }
  return (
    <div>
      <div className="ui embed">
        <iframe src={vidSrc} title="videos" />
      </div>
      <div className="ui segment">
        <h4 className="ui header">{snippet.title}</h4>
        <p>{snippet.description}</p>
      </div>
    </div>
  );
};

//////////////////////////////////////////////////////////////////////////////// react hooks
hooks system gives us the ability to make fully usefull func components without using classes.
// it simulates the state system in ClassBasedComp(CBC) with useState functions
// it simulates the ref system in ClassBasedComp(CBC) with useRef functions
// it simulates the Lifecycle methods in ClassBasedComp(CBC) with useEffect functions

// *with these primitive hooks we can create costum code to perfom repeated tasks. 

// react fragments let you wrap up jsx like div,but the react fragments arent added to the dom, but the div is.



///////////////////////////////////////////////////////////////////////////////////
// use state is a primitive react hook for FCs (functional components)
it gives us access to the state system with out using ClassBasedComps
// useState(): functional state sytem
// to set state import the useState fucntion from react.

with the array destructuring syntax [], [valueName,setvalueNameFn] = useState(null), this is to initialize the state system.

// in the array the first var in the [] syntax refers to our state property(the one whos value is to change over time). the second var in the [] syntax is a setter function that when called will update our state and rerender the app, just like this.setState({}) in ClassBasedComp

// the useState(), is a function that is used to initialize our state.

// it takes one arg which will be the default or initial value for our state property.

then to update state use setvalueNameFn(valueToSet)(setterFn)

then to reference state values use {valueName}

this process is needed to use every piece of state. if we need 3 different pieces of state we do this 3 times


// step 1 
let [value1,setValue1Fn] = useState(null)
let [value2,setValue2Fn] = useState('')
let [value3,setValue3Fn] = useState(0)

// step 2
setValue1Fn(10)
setValue2Fn('stringVALE')
setValue3Fn(5)

// step 3
h1 {value1}
h1 {value2}
h1 {value3}


/////////////////////////////////////
//// useEffect() hooks
// allows FCs to be able to use something like lifeCycle methods on classBasedComponents.
// useEffect is configured to run in 3 different scenarios.

1. When the component is rendered for the first time only. like comp did mount
2. When the component is rendered for the first time and when ever again it rerenders.
3. When the component is rendered for the first time, when ever again it rerenders and when ever some piece of data has changed


// use useEffect(),
1 import {useEffect} from react

const Funccomp = ()=>{
    useEffect(()=>{
        doStuff
    })
}

// use useEffect and configure. 
2. useEffect() takes two args. the callback that useEffect() should run and in the scenerio were useEffect should be called.(any of the 3 stated above)
1. When the component is rendered for the first time only.
useEffect(cb,[])

2. When the component is rendered for the first time and when ever again it rerenders.
useEffect(cb)

3. When the component is rendered for the first time, when ever again it rerenders and when ever some piece of data has changed.
useEffect(cb,[pieceOfData])

let [x,setX] = useState('')


cant mark useEffectFn as async, 
this wont work
// useEffect(async()=>{
    let result = await some Stuff
    setX(result)
},[x])
but can use async in a function nested.useEffect()
this will work
useEffect(()=>{
    //create function
    let somePromise = async()=>{await some stuff}
    //call function
    somePromise()

    //ie2,immiediate executables
    (async(){
        await some stuff
    })()

    //ie3 use promise then.catch() methods 
    Promise.resolve().then().catch()
})
// in the useEffect function the only value we can return is a function. this function is used by react when ever useEffect is called(either of the 3 scenarios)
// the function serves as a cleanup/maintainance to do or set something when ever useEffect is called. after the first call the returned function wont execute(because its the firsttime), but the second time and onward its then called by react and it will be executed before the callback passsed into useEffect()
// i.e
useEffect(()=>{
    // do something

    return ()=>{
        // do some other thing
    }
},[state])


////////////////////////////////////////////////
wiki Api
en.wikipedia.org/w/api.php?action=query&list=search&format=json&origin=*&srsearch=programming

// turn a html text to jsx, if we recieve html as a response, we can convert html text to jsx. but it is risky. because malicious javascript can be executed(xss). 
// use <element dangerouslySetInnerHTML={{__html:html text}}></element> 
// this leaves use open for xss attacks.




// useEffect() warnings
the depency warning happens when we reference a piece of state that is added into the second arg.
// the useEffect requires any state referenced in its scope to be in the second arg.

useEffect(()=>{
    console.log(state)
    console.log(someState)
    console.log(someOtherState)

    // like this any state referenced should be in the array
},[state,someState,someOtherState])

// this can cause bugs, because useEffect would rerender anytime either of the pieces gets updated, that mean multi uneccessary function calls, or api calls, or numerous operations.